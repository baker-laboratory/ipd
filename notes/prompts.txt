Please would like you to document the ipd/homog/hgeom.py, ipd/sym/sym.py, ipd/pdb/readstruct.py, ipd/pdb/pdbfetch.py, ipd/atom/body.py, ipd/atom/components.py, and ipd/atom/atom_utils.py. please draw from their corresponding test_*.py files to learn more about how the is used so that you can better descibe classes/functions as well as produce better usage examples. make sure you document all the way to the end of each file, as we discussed. try to have at least one doctestable example for each function that uses a body, symbody, or AtomArray.  AtomArrays can be obtained by calling ipd.atom.load(pbdcode) , using the codes below. for convenient example setup, Bodys and SymBodies can be created with body_from_file(pdbcode) and symbody_from_file(pdbcode) using pdb codes from this list (which are built in):  1A0J 1a2n 1bfr 1byf 1dxh 1g5q 1hv4 1n0e 1out 1ql2 1qys 1wa3 2btv 2tbv 3e47 3sne 3woc 5im6 5j7v 6cgr 6ncl 6q1f 7abl 8rbs 8u51

take your time and make sure they are complete and correct.  Do not change any of the source code in a way that could change behavior. the ipd package currently has 720 unit tests that all pass wiht different optional dependencies and python versioins, and I dont have to track down lots of test failures. if you have a valuable source code or architectural change to suggest, please do so, but please confirm with me. please include a extensive module level docstring with many examples, at least 10,  and a thorough description of the contents and purpose of the module. make sure usage examples can be checked with doctest, including all the various things that can be done with Atoms, Body and SymBody,  particularially clash and contact checks and sligind into contact.  please hilight that he rotationally invariant bounding volume hierarchy from hgeom (SphereBVH_double)  is very efficient, especially for large symmetrical structures... for lightly contacting structures it can be hundreds of times faster than even well engineered alternatives like the biotite cell list. the very largest virus capsids can be quickly manipulated.

please also make liberal use of the hgeom.py module's capability to crete and manipluate 4x4 homogeneour transforms, which are used to represent positions, stubs and symmetry frames throuought thi libray. import hgeom like this: from ipd import hnumpy as h, then use funcions line h.rand() to create random transformations, h.trans() to create translations, h.rot(axis, ang, cen) to create rotations, and h.xform compose transformations and apply them to stubs(also 4x4),  4x1 proints created with h.point(),   4x1  vectors created witth h.vec, and lines/rays/symaxes represented as 4x2 rays with one point and one vec createdwi hray(point, normal). use this h.x functions in your examples for all the other modules. please refer to the test files for extra inspiration for example code making use of the h. functions, particularly in ipd/tests/homog/test_hgeom.py and ipd/tests/test_sym_detect.py

it would also be lovely if you could create longer form exposition and many examples in a sphinx rst file to act as documentation page for each module. the sphinx docs shold link to each other and inclued show source. I plan to use the pydata_sphinx_theme and set up my docs like the biotite library has done. after the 7 modules above have docstrings, and you have had a chance to suggest source code / architecture changes, I would like to craete sphinx documentation for those 7 modules, a page dedicated to each_, as well as organized api docs with viewcode links.

apologies for the length of this request, but I want to make sure that the documentation is as comprehensive and helpful as possible. I am looking forward to seeing your work on this. please let me know if you need further clarification, or have something to discuss. before you proceed, could you please craete another shell script to create github issues to track the various work we are planning on these 7 files? thank you very much for your help.


'''
<instructions>
Please help me craft the following prompt. Do no create code at this time, but instead help me imporve this prompt and general plan of action for my timer. I will submit this prompt for a coding task to several ai assistants, so I would like to make sure it is well crafted, clear, and actually includes everything I am looking for. In particular analyze the feasivility of a stack based checkpoint system integrated with decorator usage for accurately keeping track of complex nested call pattens. would it be feasible to use a stack rather than the hacky interjection logic (which I think is effectively a stack with a max depth of one)
</instructions>

<summary>
I have attached below module and test code for a versitile timer utility module which can be used as a class and function decorator, as a context manager, as a module level checkpoint function for a timer stored in kw or a global timer. It also includes basic usage as a Timer class instance.  It has the ability to inject additional checkpoints while still including the runtime before the injection in the next checkpoint.  It also has different report types (sum, mean, median, min, max) as well as autolabeling with the autolabel parameter, and automatically labels checkpoints based on class/function name when used as a decorator. I am looking for a very high quality, professional level of code here. I have no problem with using third party libraries, but they must be well maintained and have a good license.  I am not interested in using libraries that are not well known or widely used.  If you suggest a third party library, please include a link to the project page and a brief description of its features.
</summary>

<code improvements>
Please suggest or make improvements, especially for more accurate results when timing nested function calls, perhaps generalizing the "injection" mechanism with a checkpoint stack (NOT a stack of timers)following function calls when used as a decorator, making sure the times spend in each function are allotted to correctly labeled checkpoints for those functions. please make suggestions for general useability and accuracy improvements. I would also like the optionI have no problem with "magical" code here, and I prefer short and highly expressive, functional code without comments. if you feel the need to comment, consider adding to the relevant docstring instead. only include comments for particularly obtuse or magical code, or where it may be uncler *why* the code is doing something nonobvious.
</code improvements>

<documentation>
please write docstrings for the module, classes and functions for this versitile and magical timer utility module.  include comprehensive usage examples including as a class and function decorator, as a context manager, usage of the module level checkpoint function for a timer stored in kw, and basic usage as a Timer class instance. include information about and an example of checkpoint interjection, where additional checkpoints can be injected while still including the runtime before the injection in the next checkpoint. have information and examples of different report types (sum, mean, median, min, max) as well as autolabeling with the autolabel parameter, as well as automatically labeling checkpoints based on class/function name when used as a decorator.
</documentation>

<tests>
please also produce a comprehensive test suite, paying special attention to any new checkpoint stack you may add (as an improvement to interjection), focusing on correctness when used as a decorator on multiple functions that may call each other in a complex pattern, sharing a single global timer and making sure all time spent in each function is accounted for correctly using a checkpoint stack when decorating functions and class members. please also consider the examples in docstrings will be tested with doctest, but keep the doctest/docstring examples simpler that the main test suite. please make sure decorating generator functions is tested.
</tests>

'''
